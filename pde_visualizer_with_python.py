# -*- coding: utf-8 -*-
"""PDE Visualizer with Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16mSq9o6Du8jAopl-kZYTC81mvn3mpaax
"""

# PDE Visualizer: Heat, Wave, and Laplace (Dirichlet)
# ---------------------------------------------------
# Heat (1D):    u_t = alpha^2 u_xx,  u(0,t)=u(L,t)=0,  u(x,0)=f(x)
# Wave (1D):    u_tt = c^2 u_xx,     u(0,t)=u(L,t)=0,  u(x,0)=f(x), u_t(x,0)=g(x)
# Laplace (2D): u_xx + u_yy = 0 on [0,Lx]x[0,Ly], with
#               u(0,y)=u(Lx,y)=u(x,0)=0 and u(x,Ly)=phi(x)
#
# Solutions are built with Fourier sine-series (eigenfunction expansions).

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # needed for 3D

# ---------- helper utilities ----------
def sine_basis_matrix(x, L, N):
    """S[n, i] = sin(n*pi*x[i]/L) for n=1..N; returns (S, n_array)."""
    n = np.arange(1, N + 1, dtype=float)
    S = np.sin(np.pi * n[:, None] * x[None, :] / L)
    return S, n

def sine_coeffs(fx, x, L, N):
    """
    Fourier sine coefficients for fx sampled on x in [0,L]:
    B_n = (2/L) * ∫_0^L f(x) sin(nπx/L) dx  (computed numerically).
    Returns (B, n, S) where S is the cached sine matrix.
    """
    S, n = sine_basis_matrix(x, L, N)
    integrand = fx[None, :] * S               # (N, Nx)
    B = (2.0 / L) * np.trapz(integrand, x, axis=1)
    return B, n, S

def plot_2d_snapshots(x, snapshots, t_values, title, xlabel="x", ylabel="u(x,t)"):
    for u, t in zip(snapshots, t_values):
        plt.plot(x, u, label=f"t = {t:.3f}")
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.legend()
    plt.grid(True)
    plt.show()

def plot_surface_xy(X, Y, U, title, xlabel="x", ylabel="t or y", zlabel="u"):
    fig = plt.figure(figsize=(7.5, 5.0))
    ax = fig.add_subplot(111, projection="3d")
    ax.plot_surface(X, Y, U, linewidth=0, antialiased=True)
    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.set_zlabel(zlabel)
    plt.show()

# ---------- parameters (edit as you like) ----------
# Common 1D spatial domain
L = 1.0
Nx = 400
N_modes = 50          # series truncation

# Heat equation params
alpha = 1.0
t_heat = np.linspace(0.00, 0.25, 120)      # times for 3D surface
t_heat_snaps = [0.00, 0.02, 0.10, 0.25]    # snapshot times

# Wave equation params
c = 1.0
omega1 = c * np.pi / L
T1 = 2.0 * np.pi / omega1                  # first-mode period = 2L/c
t_wave = np.linspace(0.0, T1, 200)         # one period
t_wave_snaps = [0.00, 0.25*T1, 0.50*T1, 0.75*T1]

# Laplace (2D rectangle) params
Lx, Ly = 1.0, 1.0
Nx_lap, Ny_lap = 200, 200

# ---------- grids ----------
x = np.linspace(0.0, L, Nx)

# ==================================================
# 1) HEAT: u_t = alpha^2 u_xx, u(0,t)=u(L,t)=0
# ==================================================
# Choose an initial condition f(x) (any function satisfying f(0)=f(L)=0 is OK;
# it will be projected into a sine series automatically).
f = np.sin(np.pi * x / L)  # example: single sine mode

B, n, S = sine_coeffs(f, x, L, N_modes)
lam = (np.pi * n / L) ** 2                    # eigenvalues
E_heat = np.exp(-alpha**2 * lam[:, None] * t_heat[None, :])   # (N, Nt)
U_heat = np.einsum("nx,n,nt->xt", S, B, E_heat)               # (Nx, Nt)

# 2D snapshots
snapshots_heat = []
for t0 in t_heat_snaps:
    E0 = np.exp(-alpha**2 * lam * t0)
    u0 = np.einsum("nx,n,n->x", S, B, E0)
    snapshots_heat.append(u0)

plot_2d_snapshots(x, snapshots_heat, t_heat_snaps, "Heat equation snapshots")
Xh, Th = np.meshgrid(x, t_heat)                   # (Nt, Nx)
plot_surface_xy(Xh, Th, U_heat.T, "Heat equation surface u(x,t)", xlabel="x", ylabel="t", zlabel="u")

# ==================================================
# 2) WAVE: u_tt = c^2 u_xx, u(0,t)=u(L,t)=0
# ==================================================
# Initial displacement f(x) and velocity g(x):
f_wave = np.sin(np.pi * x / L)
g_wave = np.zeros_like(x)

A, n_w, S_w = sine_coeffs(f_wave, x, L, N_modes)     # for f
G, _, _     = sine_coeffs(g_wave, x, L, N_modes)     # for g
omega = c * np.pi * n_w / L

# u(x,t) = sum_n [ A_n cos(ω_n t) + (G_n/ω_n) sin(ω_n t) ] sin(nπx/L)
cos_term = np.cos(omega[:, None] * t_wave[None, :])                 # (N, Nt)
sin_term = np.sin(omega[:, None] * t_wave[None, :]) / omega[:, None]
U_wave = np.einsum("nx,n,nt->xt", S_w, A, cos_term) + np.einsum("nx,n,nt->xt", S_w, G, sin_term)

# 2D snapshots
snapshots_wave = []
for t0 in t_wave_snaps:
    c0 = np.cos(omega * t0)
    s0 = np.sin(omega * t0) / omega
    u0 = np.einsum("nx,n->x", S_w, A * c0 + G * s0)
    snapshots_wave.append(u0)

plot_2d_snapshots(x, snapshots_wave, t_wave_snaps, "Wave equation snapshots")
Xw, Tw = np.meshgrid(x, t_wave)
plot_surface_xy(Xw, Tw, U_wave.T, "Wave equation surface u(x,t)", xlabel="x", ylabel="t", zlabel="u")

# ==================================================
# 3) LAPLACE (2D): u_xx + u_yy = 0 on [0,Lx]x[0,Ly]
# ==================================================
# BCs: u(0,y)=u(Lx,y)=u(x,0)=0;  u(x,Ly)=phi(x)
x_l = np.linspace(0.0, Lx, Nx_lap)
y_l = np.linspace(0.0, Ly, Ny_lap)

# Top boundary data phi(x); must be 0 at x=0 and x=Lx to match sine basis:
phi = np.sin(np.pi * x_l / Lx)             # edit if you like

# Fourier-sine series in x:
D, n_l, Sx = sine_coeffs(phi, x_l, Lx, N_modes)
Ry = np.sinh(np.pi * n_l[:, None] * y_l[None, :] / Lx) / np.sinh(np.pi * n_l[:, None] * Ly / Lx)
U_lap = np.einsum("nx,ny,n->xy", Sx, Ry, D)  # (Nx_lap, Ny_lap)

# 2D contour (x vs y)
plt.figure(figsize=(7.5, 4.8))
plt.contourf(x_l, y_l, U_lap.T, levels=40)
plt.title("Laplace equation: contour of u(x,y)")
plt.xlabel("x")
plt.ylabel("y")
plt.colorbar(label="u")
plt.grid(False)
plt.show()

# 3D surface
Xl, Yl = np.meshgrid(x_l, y_l)
fig = plt.figure(figsize=(7.5, 5.0))
ax = fig.add_subplot(111, projection="3d")
ax.plot_surface(Xl, Yl, U_lap.T, linewidth=0, antialiased=True)
ax.set_title("Laplace equation surface u(x,y)")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("u")
plt.show()

print("Done. Generated 2D snapshots and 3D surfaces for Heat, Wave, and Laplace.")
print("BCs enforced: Heat/Wave use u(0,t)=u(L,t)=0. Laplace uses u(0,y)=u(Lx,y)=u(x,0)=0 and u(x,Ly)=phi(x).")